/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package pixivus_eos_signer;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
// import java.util.Base64;
import java.security.MessageDigest;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.Signature;

import com.google.common.io.BaseEncoding;
import io.github.novacrypto.bip32.ExtendedPrivateKey;
import io.github.novacrypto.bip32.ExtendedPublicKey ;
import io.github.novacrypto.bip32.networks.Bitcoin;

import org.whispersystems.curve25519.java.curve_sigs;

import org.bouncycastle.crypto.digests.RIPEMD160Digest;

import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.binary.StringUtils;
import org.apache.commons.codec.binary.Base64;

// import systems.v.hdkey.ExtendedKey;
// import systems.v.hdkey.HDkeyException;
import systems.v.hdkey.Base58;

import org.bitcoinj.core.Utils;
import org.bitcoinj.core.ECKey;
import org.bitcoinj.core.ECKey.ECDSASignature;
import org.bitcoinj.core.Sha256Hash;
import org.bitcoinj.crypto.DeterministicKey;
import org.bitcoinj.crypto.HDKeyDerivation;
import org.bitcoinj.crypto.ChildNumber;
// import org.bitcoinj.crypto.HDPath;

import one.block.eosiojava.enums.AlgorithmEmployed;
import one.block.eosiojava.error.EosioError;
import one.block.eosiojava.error.signatureProvider.GetAvailableKeysError;
import one.block.eosiojava.error.signatureProvider.SignTransactionError;
import one.block.eosiojava.error.utilities.Base58ManipulationError;
import one.block.eosiojava.error.utilities.EOSFormatterError;
import one.block.eosiojava.error.utilities.PEMProcessorError;
import one.block.eosiojava.models.signatureProvider.EosioTransactionSignatureRequest;
import one.block.eosiojava.models.signatureProvider.EosioTransactionSignatureResponse;
import one.block.eosiojava.utilities.EOSFormatter;
import one.block.eosiosoftkeysignatureprovider.SoftKeySignatureProviderImpl;
import one.block.eosiosoftkeysignatureprovider.error.ImportKeyError;
import one.block.eosiosoftkeysignatureprovider.error.SoftKeySignatureErrorConstants;

import one.block.eosiosoftkeysignatureprovider.error.ImportKeyError;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.*;

public class App {
    
    private static String CHALLENGE    = "5HuAHNRFZoP5pR3BTN66HmxUp28zSZxckhP56G1PkrhAqwDp1d4";
    private static String SEED         = "atomakinnaka.1234";
    private static String EXPECTED_SIG = "SIG_K1_KWwRh5DbBt7o7xfnzQT2GNpivPab82WwNzSqYZZBWEzvdNY8oJtZsdtBfgpjy1BsMRtVrhgVhDPZmPo3CEUYCcMqwZLo5C";
    private static String DERIVE_PATH  = "m/44'/194'/0'/0/0";

    static class PixiKey
    {
        public PixiKey(String _wif, byte[] _extended_private_key, byte[] _extended_public_key, byte[] _private_key,  byte[] _public_key){
          this.wif                  = _wif;
          this.private_key          = _private_key;
          this.public_key           = _public_key;
          this.extended_private_key = _extended_private_key;
          this.extended_public_key  = _extended_public_key;
        }
        public String wif; 
        

        public byte[] private_key;  
        public byte[] public_key;

        public byte[] extended_private_key;  
        public byte[] extended_public_key;  
    };

    private static byte[] sha256 (String originalString) throws Exception{
      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      // String hexString     = Hex.encodeHexString(originalString.getBytes(StandardCharsets.UTF_8));
      // byte[] encodedhash   = digest.digest(hexString.getBytes(StandardCharsets.UTF_8));
      byte[] encodedhash   = digest.digest(originalString.getBytes(StandardCharsets.UTF_8));

      // digest.update(originalString.getBytes(StandardCharsets.UTF_8));
      // byte[] encodedhash = digest.digest();

      return encodedhash;
    }

    private static PixiKey calculateKey() throws Exception{

      // const seed      = account_name + '.' + password;
      String seed       = SEED;
      
      // let private_key = ecc.seedPrivate(seed);
      byte[] pk_seed    = sha256(seed);

      // let master      = hdkey.fromMasterSeed(Buffer.from(ecc.sha256(private_key.toString()), 'hex'));
      // ECKey private_key = new ECKey(pk_seed);
      // byte[] private_key =  ExtendedKey.generatePrivateKey(pk_seed, "m");
      
      System.out.println(" private key seed: " + bytes2hex(pk_seed));

      // pk_seed = new byte[0];
      ExtendedPrivateKey key = ExtendedPrivateKey.fromSeed(pk_seed, Bitcoin.MAIN_NET);
      // ExtendedPrivateKey key = ExtendedPrivateKey.createMainNetRootFromSeed(bytes2hex(pk_seed)); 

      System.out.println(" key.extendedBase58(): " + key.extendedBase58() ) ;
      // System.out.println(" key.extendedKeyByteArray(): " + bytes2hex(key.extendedKeyByteArray() )) ;
      // System.out.println(" hex(key.extendedKeyByteArray()): " + Hex.encodeHexString(key.extendedKeyByteArray()) ) ;
      //originalString.getBytes(StandardCharsets.UTF_8)
      
      // ExtendedPrivateKey child = key.derive("m/44'/194'/0'/0/0");
      key = key.derive("m/44'/194'/0'/0/0");
      System.out.println(" private key -1: " + key.extendedBase58());
      for (int index = 0; index < 10; index++) 
      {
        // parent_private_key = key.clone();
        // key                =  key.derive(DERIVE_PATH);
        byte[] priv_key_bytes     = Arrays.copyOfRange(key.extendedKeyByteArray(), 46, 46+32);
        // System.out.println(" priv_key_bytes(): " + bytes2hex(priv_key_bytes) ) ;
        key = ExtendedPrivateKey.fromSeed(priv_key_bytes, Bitcoin.MAIN_NET);
        key = key.derive("m/44'/194'/0'/0/0");
        System.out.println(" private key " + index + ": " + key.extendedBase58());
      }

      byte[] ext_private_key    = key.extendedKeyByteArray();
      ExtendedPublicKey pub_key = key.neuter();
      byte[] ext_public_key     = pub_key.extendedKeyByteArray();
      byte[] _private_key       = Arrays.copyOfRange(ext_private_key, 46, 46+32);
      byte[] _public_key        = Arrays.copyOfRange(ext_public_key, 46, 46+32);


      PixiKey myKey = new PixiKey("", ext_private_key, ext_public_key, _private_key, _public_key);
      
      return myKey;

    }
    
   

    private static String signChallenge(String pem_private_key, String pem_public_key) throws Exception{
        
        System.out.println(" ************************************* ");
        
        // String privateKeyR1EOS = "PVT_R1_g6vV9tiGqN3LkhD53pVUbxDn76PuVeR6XfmJzrnLR3PbGWLys";
        // String publicKeyR1EOS = "PUB_R1_71AYFp3Aasa2od6bwmXEQ13MMfqv4wuJwCRx1Z1dbRifrQEqZt";

        String privateKeyR1EOS = EOSFormatter.convertPEMFormattedPrivateKeyToEOSFormat(pem_private_key);
        String publicKeyR1EOS  = ""; //EOSFormatter.convertPEMFormattedPublicKeyToEOSFormat(pem_public_key, false);


        String serializedTransaction = bytes2hex(sha256(CHALLENGE));
        List<String> publicKeys = Collections.singletonList(publicKeyR1EOS);
        String chainId = ""; //"687fa513e18843ad3e820744f4ffcf93b1354036d80737db8dc444fe4b15ad17";
        EosioTransactionSignatureRequest request = new EosioTransactionSignatureRequest(serializedTransaction, publicKeys, chainId, null, false);
        SoftKeySignatureProviderImpl provider = new SoftKeySignatureProviderImpl();

        try {
            provider.importKey(privateKeyR1EOS);
        } catch (ImportKeyError importKeyError) {
            importKeyError.printStackTrace();
            throw new Exception("Should not fail here!!!");
        }

        try {
            EosioTransactionSignatureResponse response = provider.signTransaction(request);
            assertNotNull(response);
            assertEquals(serializedTransaction, response.getSerializeTransaction());
            assertEquals(1, request.getSigningPublicKeys().size());
            assertTrue(response.getSignatures().get(0).contains("SIG_R1_"));

            System.out.println(" >>> " + response.getSignatures().get(0));
            return response.getSignatures().get(0);

        } catch (SignTransactionError signTransactionError) {
            signTransactionError.printStackTrace();
            throw new Exception("Should not fail here!!!");
        }

        // return "";
    }

    private static String bytes2hex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        String tmp = null;
        for (byte b : bytes) {
            tmp = Integer.toHexString(0xFF & b);
            if (tmp.length() == 1) {     
                tmp = "0" + tmp;
            }
            sb.append(tmp);
        }
        return sb.toString();
    }

    private static byte[] getSignatureBytes(Sha256Hash hashTransaction, ECKey requiredPrivateKey) {
      boolean isGrapheneCanonical = false;
      byte[] signatureData = null;

      while (!isGrapheneCanonical) {
        
        int recId = -1;
        ECKey.ECDSASignature sig = requiredPrivateKey.sign(hashTransaction);

        for (int i = 0; i < 4; i++) {
          ECKey k = ECKey.recoverFromSignature(i, sig, hashTransaction,
              requiredPrivateKey.isCompressed());
          if (k != null && k.getPubKeyPoint()
              .equals(requiredPrivateKey.getPubKeyPoint())) {
            recId = i;
            break;
          }
        }
        // 1 header + 32 bytes for R + 32 bytes for S
        signatureData = new byte[65];
        int headerByte = recId + 27 + (requiredPrivateKey.isCompressed() ? 4 : 0);
        signatureData[0] = (byte) headerByte;
        System.arraycopy(Utils.bigIntegerToBytes(sig.r, 32), 0,
            signatureData, 1, 32);
        System.arraycopy(Utils.bigIntegerToBytes(sig.s, 32), 0,
            signatureData, 33, 32);

        // Further "canonicality" tests
        if (isCanonical(signatureData)) {
          // this.setExpiration(Util.addTime(this.getExpiration(), 1));
        } else {
          isGrapheneCanonical = true;
        }
      }
      return signatureData;

    }

    /*
    
    function toString() {
      if(signatureCache) {
          return signatureCache
      }
      signatureCache = 'SIG_K1_' + keyUtils.checkEncode(toBuffer(), 'K1')
      return signatureCache
    }

    function checkEncode(keyBuffer, keyType = null) {
      assert(Buffer.isBuffer(keyBuffer), 'expecting keyBuffer<Buffer>')
      if(keyType === 'sha256x2') { // legacy
        const checksum = hash.sha256(hash.sha256(keyBuffer)).slice(0, 4)
        return base58.encode(Buffer.concat([keyBuffer, checksum]))
      } else {
        const check = [keyBuffer]
        if(keyType) {
            check.push(Buffer.from(keyType))
        }
        const checksum = hash.ripemd160(Buffer.concat(check)).slice(0, 4)
        return base58.encode(Buffer.concat([keyBuffer, checksum]))
      }
    }
*/
    private static String checkEncode(byte[] buffer) throws Exception{
      String _type       = "K1";
      byte[] check       = buffer.clone();
      // byte[] _type_bytes = Utils.HEX.decode(_type); 
      byte[] _type_bytes = _type.getBytes(StandardCharsets.UTF_8);
      // create a destination array that is the size of the two arrays
      
      byte[] destination = new byte[check.length + _type_bytes.length];
      System.out.println(" ************************************* 1 ");
      System.arraycopy(check, 0, destination, 0, check.length);
      System.out.println(" ************************************* 2 ");
      System.arraycopy(_type_bytes, 0, destination, check.length, _type_bytes.length);
      
      // byte[] destination = check.clone();

      // byte[] sha256_destination   = Sha256Hash.hash(check);
      // byte[] checksum = Arrays.copyOfRange(Utils.sha256hash160(sha256_destination ), 0, 4);

      // byte[] sha256_destination   = Sha256Hash.hash(destination);
      // byte[] checksum = Arrays.copyOfRange(Utils.sha256hash160(sha256_destination ), 0, 4);

      // byte[] checksum = Arrays.copyOfRange(Utils.sha256hash160(check ), 0, 4);
      // byte[] checksum = Arrays.copyOfRange(Utils.sha256hash160(destination), 0, 4);
      // byte[] checksum = Arrays.copyOfRange(Utils.sha256hash160(Sha256Hash.hash(destination) ), 0, 4);

      RIPEMD160Digest digest = new RIPEMD160Digest();
      digest.update(destination, 0, destination.length);
      byte[] out = new byte[20];
      digest.doFinal(out, 0);
      byte[] checksum = Arrays.copyOfRange(out, 0, 4);

      // System.out.println(" ************************************* checksum.length " + checksum.length);
      // System.out.println(" ************************************* destination.length " + destination.length);
      byte[] result = new byte[check.length + checksum.length];
      System.out.println(" ************************************* 3 ");
      System.arraycopy(check, 0, result, 0, check.length);
      System.out.println(" ************************************* 4 ");
      System.arraycopy(checksum, 0, result, check.length, checksum.length);

      return "SIG_K1_" + Base58.encode(result);
    }

    private static boolean isCanonical(byte[] signature) {
      return ((signature[0] & 0x80) != 0) || (signature[0] == 0) || ((signature[1] & 0x80) != 0)
          || ((signature[32] & 0x80) != 0) || (signature[32] == 0) || ((signature[33] & 0x80) != 0);
    }

    private static String doSign3() throws Exception{
      
      
      PixiKey key          = calculateKey();
      
      System.out.println(" ************************************* ");
      System.out.println(" ************************************* ");
      System.out.println(" ************************************* ");
      
      ECKey signer         = ECKey.fromPrivate(key.private_key);

      /*
      
      // System.out.println(" signer.toASN1(): " + bytes2hex(signer.toASN1()));
      // System.out.println(" signer.toASN1(): " + Base64.decodeBase64(signer.toASN1()));
      // System.out.println(" signer.toASN1(): " + Base64.encodeBase64String(signer.toASN1()));
      String base64_private_key = Base64.encodeBase64String(signer.toASN1());
      // String base64_private_key = Base64.encodeBase64String(key.extended_private_key);
      System.out.println(" base64_private_key: " + base64_private_key);
      String pemFormattedPrivateKey = "-----BEGIN EC PRIVATE KEY-----\n"
                + base64_private_key + "\n"
                + "-----END EC PRIVATE KEY-----";

      // ECKey public_key = ECKey.fromPublicOnly(key.public_key);
      // String base64_public_key = Base64.encodeBase64String(public_key.toASN1());
      // System.out.println(" base64_public_key: " + base64_public_key);
      // String pemFormattedPublicKey = "-----BEGIN PUBLIC KEY-----\n" 
      //           + base64_public_key + "\n"
      //           + "-----END PUBLIC KEY-----";
      String pemFormattedPublicKey = "";
      String x             = signChallenge(pemFormattedPrivateKey, pemFormattedPublicKey);
      */

      // System.out.println(" priv to Base58: " + Base58.encode(key.private_key));
      // System.out.println(" pub to Base58: " + Base58.encode(key.public_key));

      // System.out.println(" priv to Hex: " + bytes2hex(key.private_key));
      // System.out.println(" pub to Hex: " + bytes2hex(key.public_key));

      byte[] to_signBytes  = sha256(CHALLENGE);
      Sha256Hash to_sign   = Sha256Hash.wrap(to_signBytes);
      ECDSASignature sign  = signer.sign(to_sign);
      
      byte[] signatureDER  = sign.encodeToDER();
      System.out.println(" sign.der to hex: " + bytes2hex(signatureDER));

      // System.out.println(" base64 DER: " + Base64.encodeBase64String(sign.encodeToDER()));
      
      String signatureEncoded = BaseEncoding.base16().lowerCase().encode(sign.encodeToDER());

      // System.out.println(" x: " + bytes2hex(sign.toByteArray()) );
      // System.out.println(" y: " + Base64.encodeBase64String(sign.toByteArray()) );


      byte[] result = getSignatureBytes(to_sign, signer);

      System.out.println(" result: " + bytes2hex(result) );
      System.out.println(" result: " + Base64.encodeBase64String(result) );
      System.out.println(" result: " + checkEncode(result) );
      // Signature sig = Signature.getInstance("SHA1WithRSA"); //SHA256withRSA
      // // sig.initSign(key.private_key);
      // sig.initSign(signer);
      // sig.update(to_signBytes);
      // byte[] signatureBytes = sig.sign();
      // System.out.println("Signature:" + Base64.encodeBase64String(signatureBytes));
      



      // String signString  = signer.signMessage(CHALLENGE);
      // System.out.println(" string sig: " + signString);
      
      // System.out.println(" signer pub key: " + bytes2hex(signer.getPubKey()));
      // System.out.println(" signer pub key hash: " + bytes2hex(signer.getPubKeyHash()));
      
      // System.out.println(" signer pub key: " + bytes2hex(signer.getPubKey()));
      // System.out.println(" signer pub key hash: " + bytes2hex(signer.getPubKeyHash()));
      


      return "done";
    }

    public static void main(String[] args) throws Exception{
        System.out.println(new App().doSign3());
    }
}
